#version 450

struct Intersection {
    vec3 surface_normal;
    float t;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Sphere {
    vec3 center;
    float radius;
};

layout (std430, set = 0, binding = 0) writeonly buffer Intersections {
    Intersection data[];
} intersects;

layout (std430, set = 0, binding = 1) readonly buffer Geometry {
    Sphere data[];
} geoms;

layout (std430, set = 0, binding = 2) readonly buffer Rays {
    Ray data[];
} raysSSBO;

layout (std140, set = 0, binding = 3) uniform Params {
    uint num_geoms;
    uint num_paths;
} params;

vec3 point_at(Ray ray, float t);
float sphere_intersect_test(Sphere sphere, Ray ray);

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
void main() {
    uint thid = gl_GlobalInvocationID.x;
    if (thid > params.num_paths) return;

    for (int i = 0; i < params.num_geoms; i += 1) {
        Ray r = raysSSBO.data[thid];
        float t = sphere_intersect_test(geoms.data[i], r);
        if (t > 0.0) {
            vec3 normal = normalize(point_at(r, t) - vec3(0.0, 0.0, -1));
            intersects.data[thid] = Intersection(normal, t);
        } else {
            intersects.data[thid] = Intersection(vec3(0.0), -1);
        }
    }
}

vec3 point_at(Ray ray, float t) {
    return ray.origin + (t - 1.f-4) * normalize(ray.direction);
}

float sphere_intersect_test(Sphere sphere, Ray ray) {
    vec3 oc = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float half_b = dot(oc, ray.direction);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    float discriminant = half_b * half_b - a * c;
    return (discriminant > 0) 
        ? (-half_b - sqrt(discriminant)) / a 
        : -1.0;
}
